C51 COMPILER V9.60.0.0   USBXPRESS_ECHO_MAIN                                               05/18/2024 16:34:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USBXPRESS_ECHO_MAIN
OBJECT MODULE PLACED IN .\src\USBXpress_Echo_main.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\konra\S
                    -implicityStudio\v5_workspace\USBXpressVoltmeter\src\USBXpress_Echo_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNI
                    -NGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/Simplicit
                    -yStudio/v5/developer/sdks/8051/v4.3.1//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v
                    -4.3.1//Device/C8051F320/inc) REGFILE(USBXpressVoltmeter.ORC) PRINT(.\src\USBXpress_Echo_main.lst) COND PAGEWIDTH(120) PA
                    -GELENGTH(65) OBJECT(.\src\USBXpress_Echo_main.OBJ)

line level    source

   1          /*
   2           * USBXpress_Echo_main.c
   3           *
   4           * Main routine for USBXpress Echo example.
   5           *
   6           * This example echos any data sent over usb back up to the host.
   7           * It also blinks an led at 1Hz to indicate that the core is running.
   8           *
   9           */
  10          
  11          //------------------------------------------------------------------------------
  12          // Includes
  13          
  14          #include <SI_C8051F320_Register_Enums.h>                // SFR declarations
  15          #include <si_toolchain.h>
  16          #include "efm8_usbxpress.h"
  17          #include "descriptor.h"
  18          #include <stdint.h>
  19          
  20          // -----------------------------------------------------------------------------
  21          // Global Constants
  22          
  23          #define USB_BUFFER_SIZE    512          /// Size of USB buffer
  24          
  25          SI_SBIT (LED, SFR_P2, 2);               // LED='1' means ON
  26          
  27          #define BLINK_RATE         500          // ms per blink
  28          #define SYSCLK             24000000     // SYSCLK frequency in Hz
  29          #define PRESCALE           48           //Timer prescaler
  30          #define TIMER_RELOAD -(SYSCLK / PRESCALE / 1000)
  31          
  32          #define TIMER_RELOAD_HIGH ((TIMER_RELOAD & 0xFF00)>>8)
  33          #define TIMER_RELOAD_LOW (TIMER_RELOAD & 0x00FF)
  34          
  35          // -----------------------------------------------------------------------------
  36          // Function Prototypes
  37          
  38          void Delay (void);
  39          void Sysclk_Init (void);
  40          void Port_Init (void);
  41          void Timer0_Init ();
  42          void my_usbxp_callback(void);
  43          
  44          // -----------------------------------------------------------------------------
  45          // Variable Declarations
  46          
  47          SI_SEGMENT_VARIABLE(timerCounter, uint16_t, SI_SEG_XDATA);
  48          
  49          /// Buffer for holding USB data
  50          SI_SEGMENT_VARIABLE(usbBuffer[USB_BUFFER_SIZE], uint8_t, SI_SEG_XDATA);
  51          
C51 COMPILER V9.60.0.0   USBXPRESS_ECHO_MAIN                                               05/18/2024 16:34:12 PAGE 2   

  52          // -----------------------------------------------------------------------------
  53          // Functions
  54          
  55          //-----------------------------------------------------------------------------
  56          // SiLabs_Startup() Routine
  57          // ----------------------------------------------------------------------------
  58          // This function is called immediately after reset, before the initialization
  59          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  60          // useful place to disable the watchdog timer, which is enable by default
  61          // and may trigger before main() in some instances.
  62          //-----------------------------------------------------------------------------
  63          void SiLabs_Startup (void)
  64          {
  65   1        PCA0MD &= ~PCA0MD_WDTE__BMASK;         // Disable watchdog timer
  66   1      }
  67           
  68          /**************************************************************************//**
  69           * @brief Main loop
  70           *
  71           * The main loop sets up the device and then waits forever. All active tasks
  72           * are ISR driven.
  73           *
  74           *****************************************************************************/
  75          void main (void)
  76          {
  77   1      
  78   1      
  79   1        VDM0CN = VDM0CN_VDMEN__ENABLED;        // Enable VDD Monitor
  80   1        Delay ();                              // Wait for VDD Monitor to stabilize
  81   1        RSTSRC = RSTSRC_PORSF__SET;            // Enable VDD Monitor as a reset source
  82   1      
  83   1        Sysclk_Init ();                        // Initialize system clock
  84   1        Port_Init ();                          // Initialize crossbar and GPIO
  85   1        Timer0_Init();                         // Initialize Timer0
  86   1      
  87   1        // USBXpress Initialization
  88   1        USBX_init(&initStruct);
  89   1      
  90   1        // Enable USBXpress API interrupts
  91   1        USBX_apiCallbackEnable(my_usbxp_callback);
  92   1      
  93   1        IE_EA = 1;       // Enable global interrupts
  94   1      
  95   1        while (1)
  96   1        {
  97   2        }                                // Spin forever
  98   1      }
  99          
 100          
 101          // -------------------------------
 102          // Interrupt Service Routines
 103          
 104          /**************************************************************************//**
 105           * @brief Timer0_ISR
 106           *
 107           * This routine changes the state of the LED whenever Timer0 overflows.
 108           *
 109           *****************************************************************************/
 110          SI_INTERRUPT(Timer0_ISR, TIMER0_IRQn)
 111          {
 112   1          TH0 = TIMER_RELOAD_HIGH;            // Reload Timer0 High register
 113   1          TL0 = TIMER_RELOAD_LOW;             // Reload Timer0 Low register
 114   1      
C51 COMPILER V9.60.0.0   USBXPRESS_ECHO_MAIN                                               05/18/2024 16:34:12 PAGE 3   

 115   1          timerCounter++;
 116   1          if(timerCounter >= BLINK_RATE)
 117   1          {
 118   2            LED = !LED;                       // Change state of LED
 119   2            timerCounter = 0;
 120   2          }
 121   1      }
 122          
 123          /**************************************************************************//**
 124           * @brief USBXpress call-back
 125           *
 126           * This function is called by USBXpress. In this example any received data
 127           * sent back up to the host.
 128           *
 129           *****************************************************************************/
 130          void my_usbxp_callback(void)
 131          {
 132   1        SI_SEGMENT_VARIABLE(readLen, uint16_t, SI_SEG_IDATA);
 133   1        SI_SEGMENT_VARIABLE(writeLen, uint16_t, SI_SEG_IDATA);
 134   1        uint32_t intval = USBX_getCallbackSource();
 135   1      
 136   1        // Suspend
 137   1        if (intval & USBX_DEV_SUSPEND)
 138   1        {
 139   2          // Turn off LED
 140   2          LED = 0;
 141   2      
 142   2          // Enter suspend mode to save power
 143   2          USBX_suspend();
 144   2        }
 145   1      
 146   1        // Device opened
 147   1        if (intval & USBX_DEV_OPEN)
 148   1        {
 149   2          // Prime first read
 150   2          USBX_blockRead(usbBuffer, USB_BUFFER_SIZE, &readLen);
 151   2        }
 152   1      
 153   1        // USB read complete
 154   1        if (intval & USBX_RX_COMPLETE)
 155   1        {
 156   2          // If data was received, echo it back to the host
 157   2          if (readLen)
 158   2          {
 159   3            USBX_blockWrite(usbBuffer, readLen, &writeLen);
 160   3          }
 161   2          // If data of zero-length was received, start a new read
 162   2          else
 163   2          {
 164   3            USBX_blockRead(usbBuffer, USB_BUFFER_SIZE, &readLen);
 165   3          }
 166   2        }
 167   1      
 168   1        // USB write complete
 169   1        if (intval & USBX_TX_COMPLETE)
 170   1        {
 171   2          // The data was sent to the host, so start a new read
 172   2          USBX_blockRead(usbBuffer, USB_BUFFER_SIZE, &readLen);
 173   2        }
 174   1      }
 175          
 176          // -------------------------------
 177          // Initialization Functions
C51 COMPILER V9.60.0.0   USBXPRESS_ECHO_MAIN                                               05/18/2024 16:34:12 PAGE 4   

 178          
 179          /**************************************************************************//**
 180           * @brief clock initialization
 181           *
 182           * Set fastest system clock (48Mhz)
 183           *****************************************************************************/
 184          void Sysclk_Init (void)
 185          {
 186   1        OSCICN  |= OSCICN_IOSCEN__ENABLED
 187   1                   | OSCICN_IFCN__HFOSC_DIV_1;        // Select full speed HFOSC
 188   1      
 189   1        CLKMUL = 0x00;                                //clear multiplier
 190   1        CLKMUL |= CLKMUL_MULEN__ENABLED;              //enable multiplier
 191   1        Delay();
 192   1        CLKMUL |= CLKMUL_MULINIT__SET;                //Initialize multiplier
 193   1        Delay();
 194   1      
 195   1        while(!(CLKMUL & CLKMUL_MULRDY__BMASK));      // Wait for multiplier to lock
 196   1      
 197   1        CLKSEL = CLKSEL_CLKSL__CLKMUL_DIV_2;          // select max sysclk
 198   1      }
 199          
 200          /**************************************************************************//**
 201           * @brief Port initialization
 202           *
 203           * P2.2   digital   push-pull    LED1
 204           *
 205           *****************************************************************************/
 206          static void Port_Init (void)
 207          {
 208   1         P2MDOUT   = P2MDOUT_B2__PUSH_PULL;   // P2.2 is push-pull
 209   1         XBR1      = XBR1_XBARE__ENABLED;     // Enable the crossbar
 210   1      }
 211          
 212          /**************************************************************************//**
 213           * @brief Timer initialization
 214           *
 215           * @param counts:
 216           *   calculated Timer overflow rate range is positive range of integer: 0 to 32767
 217           *
 218           * Configure Timer0 to 16-bit auto-reload and generate an interrupt at
 219           * interval specified by <counts> using SYSCLK/48 as its time base.
 220           *
 221           *****************************************************************************/
 222          void Timer0_Init()
 223          {
 224   1         TH0 = TIMER_RELOAD_HIGH;            // Init Timer0 High register
 225   1         TL0 = TIMER_RELOAD_LOW;             // Init Timer0 Low register
 226   1         TMOD = TMOD_T0M__MODE1;             // Timer0 in 16-bit mode
 227   1         CKCON = CKCON_SCA__SYSCLK_DIV_48;   // Timer0 uses a 1:48 prescaler
 228   1         IE_ET0 = 1;                         // Timer0 interrupt enabled
 229   1         TCON = TCON_TR0__RUN;               // Timer0 ON
 230   1      }
 231          
 232          
 233          /**************************************************************************//**
 234           * @breif delay for approximately 1ms @ 48Mhz
 235           *
 236           *****************************************************************************/
 237          void Delay (void)
 238          {
 239   1         int16_t x;
 240   1         for (x = 0; x < 500; x)
C51 COMPILER V9.60.0.0   USBXPRESS_ECHO_MAIN                                               05/18/2024 16:34:12 PAGE 5   

 241   1         {
 242   2            x++;
 243   2         }
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    308    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    514    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----       4
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
